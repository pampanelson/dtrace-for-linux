/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only.
 * See the file usr/src/LICENSING.NOTICE in this distribution or
 * http://www.opensolaris.org/license/ for details.
 */

#pragma ident	"@(#)io.d.in	1.3	04/09/28 SMI"

#pragma D depends_on module unix
#pragma D depends_on provider io

inline int B_BUSY = @B_BUSY@;
#pragma D binding "1.0" B_BUSY
inline int B_DONE = @B_DONE@;
#pragma D binding "1.0" B_DONE
inline int B_ERROR = @B_ERROR@;
#pragma D binding "1.0" B_ERROR
inline int B_PAGEIO = @B_PAGEIO@;
#pragma D binding "1.0" B_PAGEIO
inline int B_PHYS = @B_PHYS@;
#pragma D binding "1.0" B_PHYS
inline int B_READ = @B_READ@;
#pragma D binding "1.0" B_READ
inline int B_WRITE = @B_WRITE@;
#pragma D binding "1.0" B_WRITE
inline int B_ASYNC = @B_ASYNC@;
#pragma D binding "1.0" B_ASYNC

typedef struct bufinfo {
	int b_flags;			/* buffer status */
	size_t b_bcount;		/* number of bytes */
	caddr_t b_addr;			/* buffer address */
	uint64_t b_lblkno;		/* block # on device */
	uint64_t b_blkno;		/* expanded block # on device */
	size_t b_resid;			/* # of bytes not transferred */
	size_t b_bufsize;		/* size of allocated buffer */
	caddr_t b_iodone;		/* I/O completion routine */
	int b_error;			/* expanded error field */
	dev_t b_edev;			/* extended device */
} bufinfo_t;

translator bufinfo_t < struct buf *B > {
	b_flags = B->b_flags;
	b_addr = B->b_un.b_addr;
	b_bcount = B->b_bcount;
	b_lblkno = B->_b_blkno._f;
	b_blkno = sizeof (long) == 8 ? B->_b_blkno._f : B->_b_blkno._p._l;
	b_bufsize = B->b_bufsize;
	b_iodone = (caddr_t)B->b_iodone;
	b_error = B->b_error;
	b_edev = B->b_edev;
}; 

typedef struct devinfo {
	int dev_major;			/* major number */
	int dev_minor;			/* minor number */
	int dev_instance;		/* instance number */
	string dev_name;		/* name of device */
	string dev_statname;		/* name of device + instance/minor */
	string dev_pathname;		/* pathname of device */
} devinfo_t;

translator devinfo_t < struct buf *B > {
	dev_major = B->b_dip != NULL ? getmajor(B->b_edev) :
	    getmajor(B->b_file->v_vfsp->vfs_dev);
	dev_minor = B->b_dip != NULL ? getminor(B->b_edev) :
	    getminor(B->b_file->v_vfsp->vfs_dev);
	dev_instance = B->b_dip == NULL ? 
	    getminor(B->b_file->v_vfsp->vfs_dev) :
	    ((struct dev_info *)B->b_dip)->devi_instance;
	dev_name = B->b_dip == NULL ? "nfs" :
	    stringof(`devnamesp[getmajor(B->b_edev)].dn_name);
	dev_statname = strjoin(B->b_dip == NULL ? "nfs" :
	    stringof(`devnamesp[getmajor(B->b_edev)].dn_name),
	    lltostr(B->b_dip == NULL ? getminor(B->b_file->v_vfsp->vfs_dev) :
	    ((struct dev_info *)B->b_dip)->devi_instance == 0 &&
	    ((struct dev_info *)B->b_dip)->devi_parent != NULL &&
	    ((struct dev_info *)B->b_dip)->devi_parent->devi_node_name ==
	    "pseudo" ? getminor(B->b_edev) :
	    ((struct dev_info *)B->b_dip)->devi_instance));
	dev_pathname = B->b_dip == NULL ? "<nfs>" :
	    ddi_pathname(B->b_dip, getminor(B->b_edev));
};

typedef struct fileinfo {
	string fi_name;			/* name (basename of fi_pathname) */
	string fi_dirname;		/* directory (dirname of fi_pathname) */
	string fi_pathname;		/* full pathname */
	offset_t fi_offset;		/* offset within file */
	string fi_fs;			/* filesystem */
	string fi_mount;		/* mount point of file system */
} fileinfo_t;

translator fileinfo_t < struct buf *B > {
	fi_name = B->b_file == NULL ? "<none>" :
	    B->b_file->v_path == NULL ? "<unknown>" :
	    basename(cleanpath(B->b_file->v_path));
	fi_dirname = B->b_file == NULL ? "<none>" :
	    B->b_file->v_path == NULL ? "<unknown>" :
	    dirname(cleanpath(B->b_file->v_path));
	fi_pathname = B->b_file == NULL ? "<none>" :
	    B->b_file->v_path == NULL ? "<unknown>" :
	    cleanpath(B->b_file->v_path);
	fi_offset = B->b_offset;
	fi_fs = B->b_file == NULL ? "<none>" :
	    stringof(B->b_file->v_op->vnop_name);
	fi_mount = B->b_file == NULL ? "<none>" :
	    B->b_file->v_vfsp->vfs_vnodecovered == NULL ? "/" :
	    B->b_file->v_vfsp->vfs_vnodecovered->v_path == NULL ? "<unknown>" :
	    cleanpath(B->b_file->v_vfsp->vfs_vnodecovered->v_path);
};
