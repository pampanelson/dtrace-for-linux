#! /usr/bin/perl

# $Header:$

# Handle syscall names which vary in location and available from
# one kernel and architecture to the next.

# Author: Paul Fox
# Date: June 2008

use strict;
use warnings;

use File::Basename;
use FileHandle;
use Getopt::Long;
use IO::File;
use POSIX;

#######################################################################
#   Command line switches.					      #
#######################################################################
my %opts;

sub main
{
	Getopt::Long::Configure('no_ignore_case');
	usage() unless GetOptions(\%opts,
		'help',
		);

	usage() if ($opts{help});
	usage() if !$ARGV[0];

	die "\$BUILD_DIR must be defined before running this script" if !$ENV{BUILD_DIR};

	my $ver = `uname -r`;
	chomp($ver);

        my $bits = 0;
        my $machine = `uname -m`;
        if ($machine =~ /x86_64/) {
        	$bits = 64;
        } elsif ($machine =~ /i[34567]86/) {
        	$bits = 32;
        } else {
        	die "Unexpected machine: $machine";
        }

	my %calls;
        my @unistd_h_candidates = (
             # linux-2.6.15, 2.6.23:
             "/lib/modules/$ver/build/include/asm/unistd.h",
             # linux-2.6.26:
             "/lib/modules/$ver/build/include/asm-x86/unistd_$bits.h",
             # linux-2.6.28-rc7:
             "/lib/modules/$ver/build/arch/x86/include/asm/unistd_$bits.h"
             );

        my $syscall_count = 0;
        foreach my $f (@unistd_h_candidates) {
		next if ! -e $f;

		print "Processing: $f\n";
		my $fh = new FileHandle($f);
		if (!$fh) {
			die "Cannot open $f: $!";
		}
		while (<$fh>) {
			next if !/define\s+(__NR[A-Z_a-z0-9]+)\s+(.*)/;
			$calls{$1} = $2;
                        $syscall_count += 1;
		}
		###############################################
		#   We  may  hit  unistd.h  which  in  turn,  #
		#   includes  unistd_32.h or unistd_64.h, so  #
		#   see  if  we  can go for one of the other  #
		#   files, if we got nothing useful.	      #
		###############################################
                last if scalar(keys(%calls));
	}

        # Make sure we've found reasonable number of system calls.
        # 2.6.15 i386 has 300+, x86_64 has 255
        die "Unable to generate syscall table, syscall_count==$syscall_count, which looks\nsuspiciously too low. Might have misparsed the sys_call_table\n" if $syscall_count < 200;

	my $name = $ARGV[0];
	my $dir = dirname($0);
	my $fname = "$ENV{BUILD_DIR}/driver/syscalls-$name.tbl";
	my $fh = new FileHandle(">$fname");
	print "Creating: $fname - ", scalar(keys(%calls)), " entries\n";
	die "Cannot create: $fname -- $!" if !$fh;

	print $fh "/* This file is automatically generated from mksyscall.pl */\n";
	print $fh "/* Do not edit! */\n";
	foreach my $c (sort(keys(%calls))) {
		print $fh "#if defined($c)\n";
		print $fh " [$c] = \"$c\",\n";
		print $fh "#endif\n";
	}

}
#######################################################################
#   Print out command line usage.				      #
#######################################################################
sub usage
{
	print <<EOF;
mksyscall.pl: Compile up the sys_call_table string entries for the driver.
Usage: mksyscall.pl [x86 | x86-64]
EOF
	exit(1);
}

main();
0;

